/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * REMESITA API REST
 * Api de remesita.com para desarrolladores. Primero obten tu apiKey y apiSecret, y para autenticarte debes ejecutar el endpoint rest/v1/auth en la respuesta obtendrás un token de acceso que debes usar en el resto de peticiones
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://remesita.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * Número de tarjeta Visa de origen
     * @type {string}
     * @memberof Body
     */
    from: string;
    /**
     * Número de tarjeta Visa de destino
     * @type {string}
     * @memberof Body
     */
    to: string;
    /**
     * Monto a transferir
     * @type {number}
     * @memberof Body
     */
    amount: number;
    /**
     * Moneda de la transferencia (MXN o USD). Si no se envía, se asume USD por defecto.
     * @type {string}
     * @memberof Body
     */
    currency?: string;
    /**
     * Comentario o concepto de la transacción
     * @type {string}
     * @memberof Body
     */
    memo: string;
}

/**
 * 
 * @export
 * @interface Body1
 */
export interface Body1 {
    /**
     * ID del negocio que está generando el link de pago
     * @type {string}
     * @memberof Body1
     */
    businessUnitId: string;
    /**
     * Monto a pagar
     * @type {number}
     * @memberof Body1
     */
    amount: number;
    /**
     * Concepto de pago o comentario
     * @type {string}
     * @memberof Body1
     */
    concept: string;
    /**
     * Dirección para recibir webhooks de notificaciones de pago en segundo plano
     * @type {string}
     * @memberof Body1
     */
    ipnUrl?: string;
    /**
     * URL a donde redireccionar si el pago es satisfactorio
     * @type {string}
     * @memberof Body1
     */
    successUrl?: string;
    /**
     * URL a donde redireccionar si el pago es cancelado
     * @type {string}
     * @memberof Body1
     */
    cancelUrl?: string;
    /**
     * Identificador externo para trazabilidad
     * @type {string}
     * @memberof Body1
     */
    customId?: string;
    /**
     * Nombre del pagador (si se conoce)
     * @type {string}
     * @memberof Body1
     */
    payerName?: string;
    /**
     * Teléfono del pagador (si se conoce)
     * @type {string}
     * @memberof Body1
     */
    payerPhone?: string;
    /**
     * Email del pagador (si se conoce)
     * @type {string}
     * @memberof Body1
     */
    payerEmail?: string;
}

/**
 * 
 * @export
 * @interface Body2
 */
export interface Body2 {
    /**
     * 
     * @type {string}
     * @memberof Body2
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Body2
     */
    apiSecret?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * ID único del negocio
     * @type {string}
     * @memberof InlineResponse200
     */
    id?: string;
    /**
     * Nombre del negocio
     * @type {string}
     * @memberof InlineResponse200
     */
    name?: string;
    /**
     * Descripción del negocio
     * @type {string}
     * @memberof InlineResponse200
     */
    description?: string;
    /**
     * Logo del negocio
     * @type {string}
     * @memberof InlineResponse200
     */
    logo?: string;
    /**
     * Dominio del negocio
     * @type {string}
     * @memberof InlineResponse200
     */
    domain?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Indica si la transferencia fue exitosa
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    success?: boolean;
    /**
     * Mensaje de error en caso de fallo
     * @type {string}
     * @memberof InlineResponse2001
     */
    error?: string;
    /**
     * ID de la transacción en caso de éxito
     * @type {string}
     * @memberof InlineResponse2001
     */
    tid?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    lockStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    error?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<InlineResponse2003Items>}
     * @memberof InlineResponse2003
     */
    items?: Array<InlineResponse2003Items>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    pg?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    pgSize?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    pages?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    total?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    allowNext?: boolean;
}

/**
 * 
 * @export
 * @interface InlineResponse2003Items
 */
export interface InlineResponse2003Items {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Items
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Items
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Items
     */
    amountUSD?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Items
     */
    exchangeRate?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    payee?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Items
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Items>}
     * @memberof InlineResponse2004
     */
    items?: Array<InlineResponse2004Items>;
    /**
     * Total de tarjetas
     * @type {number}
     * @memberof InlineResponse2004
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2004Items
 */
export interface InlineResponse2004Items {
    /**
     * Balance de la tarjeta
     * @type {number}
     * @memberof InlineResponse2004Items
     */
    balance?: number;
    /**
     * Balance de la tarjeta formateado
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    balanceFormatted?: string;
    /**
     * Balance en USD
     * @type {number}
     * @memberof InlineResponse2004Items
     */
    balanceUSD?: number;
    /**
     * Balance en USD formateado
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    balanceUSDFormatted?: string;
    /**
     * Estado de la tarjeta
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    status?: string;
    /**
     * Número de la tarjeta
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    number?: string;
    /**
     * Número de la tarjeta formateado
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    numberFormatted?: string;
    /**
     * Tasa de cambio
     * @type {number}
     * @memberof InlineResponse2004Items
     */
    exchangeRate?: number;
    /**
     * CLABE de la tarjeta
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    clabe?: string;
    /**
     * Referencia de efectivo
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    cashReference?: string;
    /**
     * Indica si la tarjeta está bloqueada
     * @type {boolean}
     * @memberof InlineResponse2004Items
     */
    locked?: boolean;
    /**
     * Alias de la tarjeta
     * @type {string}
     * @memberof InlineResponse2004Items
     */
    alias?: string;
    /**
     * Indica si es la tarjeta principal
     * @type {boolean}
     * @memberof InlineResponse2004Items
     */
    main?: boolean;
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<InlineResponse2005Items>}
     * @memberof InlineResponse2005
     */
    items?: Array<InlineResponse2005Items>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    pg?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    pgSize?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    pages?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    total?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    allowNext?: boolean;
}

/**
 * 
 * @export
 * @interface InlineResponse2005Items
 */
export interface InlineResponse2005Items {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    speedMode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    recipientAccount?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    swift?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    institution?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    senderName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    senderCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    recipientName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    recipientCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    recipientRelationship?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    paymentMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    quotation?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    senderCurrency?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005Items
     */
    exchangeRate?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    lifeTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2005Items
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2005Items
     */
    payedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2005Items
     */
    cancelAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2005Items
     */
    completedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    institutionIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    cancelReason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Items
     */
    intent?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    pg?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    pgSize?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    pages?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    total?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    allowNext?: boolean;
    /**
     * 
     * @type {Array<InlineResponse2006Items>}
     * @memberof InlineResponse2006
     */
    items?: Array<InlineResponse2006Items>;
}

/**
 * 
 * @export
 * @interface InlineResponse2006Items
 */
export interface InlineResponse2006Items {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006Items
     */
    match?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    order?: string;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2006Items
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InlineResponse2006Items
     */
    completedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    paymentMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    sku?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006Items
     */
    quotation?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    quotationCurrency?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Items
     */
    recipientAccount?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006Items
     */
    recipientAmount?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * Link acortado listo para ser redireccionado
     * @type {string}
     * @memberof InlineResponse2007
     */
    link?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    accessToken?: string;
    /**
     * 
     * @type {InlineResponse2008User}
     * @memberof InlineResponse2008
     */
    user?: InlineResponse2008User;
}

/**
 * 
 * @export
 * @interface InlineResponse2008User
 */
export interface InlineResponse2008User {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    uid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    pictureUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    mainCard?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    level?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008User
     */
    countryISO?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * Balance combinado de la tarjeta prepago
     * @type {number}
     * @memberof InlineResponse2009
     */
    prepaidCardCombinedBalance?: number;
    /**
     * Balance combinado de la tarjeta prepago en USD
     * @type {number}
     * @memberof InlineResponse2009
     */
    prepaidCardCombinedBalanceUsd?: number;
    /**
     * Comisión de referidos
     * @type {number}
     * @memberof InlineResponse2009
     */
    referralsCommission?: number;
    /**
     * Tasa de cambio de USD a MXN
     * @type {number}
     * @memberof InlineResponse2009
     */
    usd2mxn?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse401
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse404
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
}


/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Autentica al usuario con api_key y api_secret
         * @param {Body2} body JSON con api_key y api_secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1AuthPost(body: Body2, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restV1AuthPost.');
            }
            const localVarPath = `/rest/v1/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Autentica al usuario con api_key y api_secret
         * @param {Body2} body JSON con api_key y api_secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1AuthPost(body: Body2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).restV1AuthPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Autentica al usuario con api_key y api_secret
         * @param {Body2} body JSON con api_key y api_secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1AuthPost(body: Body2, options?: any) {
            return AuthenticationApiFp(configuration).restV1AuthPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Autentica al usuario con api_key y api_secret
     * @param {Body2} body JSON con api_key y api_secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public restV1AuthPost(body: Body2, options?: any) {
        return AuthenticationApiFp(this.configuration).restV1AuthPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * BusinessApi - fetch parameter creator
 * @export
 */
export const BusinessApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Devuelve una lista de todos los negocios registrados en remesita
         * @summary Obtiene la lista de negocios registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BusinessGet(options: any = {}): FetchArgs {
            const localVarPath = `/rest/v1/business`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un link de pago basado en los detalles proporcionados
         * @summary Genera un link de pago
         * @param {Body1} body Detalles para generar el link de pago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1PaymentLinkPost(body: Body1, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restV1PaymentLinkPost.');
            }
            const localVarPath = `/rest/v1/payment-link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessApi - functional programming interface
 * @export
 */
export const BusinessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Devuelve una lista de todos los negocios registrados en remesita
         * @summary Obtiene la lista de negocios registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BusinessGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200>> {
            const localVarFetchArgs = BusinessApiFetchParamCreator(configuration).restV1BusinessGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Crea un link de pago basado en los detalles proporcionados
         * @summary Genera un link de pago
         * @param {Body1} body Detalles para generar el link de pago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1PaymentLinkPost(body: Body1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = BusinessApiFetchParamCreator(configuration).restV1PaymentLinkPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BusinessApi - factory interface
 * @export
 */
export const BusinessApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Devuelve una lista de todos los negocios registrados en remesita
         * @summary Obtiene la lista de negocios registrados
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BusinessGet(options?: any) {
            return BusinessApiFp(configuration).restV1BusinessGet(options)(fetch, basePath);
        },
        /**
         * Crea un link de pago basado en los detalles proporcionados
         * @summary Genera un link de pago
         * @param {Body1} body Detalles para generar el link de pago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1PaymentLinkPost(body: Body1, options?: any) {
            return BusinessApiFp(configuration).restV1PaymentLinkPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * BusinessApi - object-oriented interface
 * @export
 * @class BusinessApi
 * @extends {BaseAPI}
 */
export class BusinessApi extends BaseAPI {
    /**
     * Devuelve una lista de todos los negocios registrados en remesita
     * @summary Obtiene la lista de negocios registrados
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public restV1BusinessGet(options?: any) {
        return BusinessApiFp(this.configuration).restV1BusinessGet(options)(this.fetch, this.basePath);
    }

    /**
     * Crea un link de pago basado en los detalles proporcionados
     * @summary Genera un link de pago
     * @param {Body1} body Detalles para generar el link de pago
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public restV1PaymentLinkPost(body: Body1, options?: any) {
        return BusinessApiFp(this.configuration).restV1PaymentLinkPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodeGet(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling restV1UserLockupCodeCodeGet.');
            }
            const localVarPath = `/rest/v1/user/lockup-code/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodeGet(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).restV1UserLockupCodeCodeGet(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodeGet(code: string, options?: any) {
            return DefaultApiFp(configuration).restV1UserLockupCodeCodeGet(code, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public restV1UserLockupCodeCodeGet(code: string, options?: any) {
        return DefaultApiFp(this.configuration).restV1UserLockupCodeCodeGet(code, options)(this.fetch, this.basePath);
    }

}

/**
 * OperationsApi - fetch parameter creator
 * @export
 */
export const OperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Recupera una lista paginada de órdenes
         * @summary Obtiene una lista de órdenes
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled'} [status] Estado para filtrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationOrdersGet(pg?: number, pgSize?: number, start?: Date, end?: Date, status?: 'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled', options: any = {}): FetchArgs {
            const localVarPath = `/rest/v1/operation/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (pg !== undefined) {
                localVarQueryParameter['pg'] = pg;
            }

            if (pgSize !== undefined) {
                localVarQueryParameter['pgSize'] = pgSize;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista paginada de operaciones P2P
         * @summary Obtiene una lista de operaciones P2P
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationP2pGet(pg?: number, pgSize?: number, start?: Date, end?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/rest/v1/operation/p2p`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (pg !== undefined) {
                localVarQueryParameter['pg'] = pg;
            }

            if (pgSize !== undefined) {
                localVarQueryParameter['pgSize'] = pgSize;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Recupera una lista paginada de órdenes
         * @summary Obtiene una lista de órdenes
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled'} [status] Estado para filtrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationOrdersGet(pg?: number, pgSize?: number, start?: Date, end?: Date, status?: 'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = OperationsApiFetchParamCreator(configuration).restV1OperationOrdersGet(pg, pgSize, start, end, status, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Recupera una lista paginada de operaciones P2P
         * @summary Obtiene una lista de operaciones P2P
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationP2pGet(pg?: number, pgSize?: number, start?: Date, end?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = OperationsApiFetchParamCreator(configuration).restV1OperationP2pGet(pg, pgSize, start, end, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Recupera una lista paginada de órdenes
         * @summary Obtiene una lista de órdenes
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled'} [status] Estado para filtrar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationOrdersGet(pg?: number, pgSize?: number, start?: Date, end?: Date, status?: 'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled', options?: any) {
            return OperationsApiFp(configuration).restV1OperationOrdersGet(pg, pgSize, start, end, status, options)(fetch, basePath);
        },
        /**
         * Recupera una lista paginada de operaciones P2P
         * @summary Obtiene una lista de operaciones P2P
         * @param {number} [pg] Número de página
         * @param {number} [pgSize] Cantidad de elementos por página
         * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
         * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1OperationP2pGet(pg?: number, pgSize?: number, start?: Date, end?: Date, options?: any) {
            return OperationsApiFp(configuration).restV1OperationP2pGet(pg, pgSize, start, end, options)(fetch, basePath);
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * Recupera una lista paginada de órdenes
     * @summary Obtiene una lista de órdenes
     * @param {number} [pg] Número de página
     * @param {number} [pgSize] Cantidad de elementos por página
     * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
     * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
     * @param {'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled'} [status] Estado para filtrar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public restV1OperationOrdersGet(pg?: number, pgSize?: number, start?: Date, end?: Date, status?: 'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled', options?: any) {
        return OperationsApiFp(this.configuration).restV1OperationOrdersGet(pg, pgSize, start, end, status, options)(this.fetch, this.basePath);
    }

    /**
     * Recupera una lista paginada de operaciones P2P
     * @summary Obtiene una lista de operaciones P2P
     * @param {number} [pg] Número de página
     * @param {number} [pgSize] Cantidad de elementos por página
     * @param {Date} [start] Fecha de inicio en formato Y-m-d H:i:s
     * @param {Date} [end] Fecha de finalización en formato Y-m-d H:i:s
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public restV1OperationP2pGet(pg?: number, pgSize?: number, start?: Date, end?: Date, options?: any) {
        return OperationsApiFp(this.configuration).restV1OperationP2pGet(pg, pgSize, start, end, options)(this.fetch, this.basePath);
    }

}

/**
 * PrepaidCardsApi - fetch parameter creator
 * @export
 */
export const PrepaidCardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cambia el estado de bloqueo de una tarjeta específica
         * @summary Bloquea o desbloquea una tarjeta
         * @param {string} number Número de tarjeta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTogglePost(number: string, options: any = {}): FetchArgs {
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling restV1CardNumberTogglePost.');
            }
            const localVarPath = `/rest/v1/card/{number}/toggle`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista paginada de transacciones para una tarjeta específica
         * @summary Obtiene las transacciones de una tarjeta
         * @param {string} number Número de tarjeta
         * @param {number} pg Número de página
         * @param {number} pgSize Tamaño de página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTransactionsPgPgSizeGet(number: string, pg: number, pgSize: number, options: any = {}): FetchArgs {
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
            }
            // verify required parameter 'pg' is not null or undefined
            if (pg === null || pg === undefined) {
                throw new RequiredError('pg','Required parameter pg was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
            }
            // verify required parameter 'pgSize' is not null or undefined
            if (pgSize === null || pgSize === undefined) {
                throw new RequiredError('pgSize','Required parameter pgSize was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
            }
            const localVarPath = `/rest/v1/card/{number}/transactions/{pg}/{pgSize}`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)))
                .replace(`{${"pg"}}`, encodeURIComponent(String(pg)))
                .replace(`{${"pgSize"}}`, encodeURIComponent(String(pgSize)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite transferir saldo entre dos cuentas Remesita especificadas por los números de tarjeta Visa.
         * @summary Transfiere saldo entre cuentas Remesita
         * @param {Body} body Detalles de la transferencia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardTransferBetweenPost(body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restV1CardTransferBetweenPost.');
            }
            const localVarPath = `/rest/v1/card/transfer-between`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve una lista de todas las tarjetas prepagadas en el sistema
         * @summary Obtiene la lista de tarjetas prepagadas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardsGet(options: any = {}): FetchArgs {
            const localVarPath = `/rest/v1/cards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrepaidCardsApi - functional programming interface
 * @export
 */
export const PrepaidCardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cambia el estado de bloqueo de una tarjeta específica
         * @summary Bloquea o desbloquea una tarjeta
         * @param {string} number Número de tarjeta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTogglePost(number: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = PrepaidCardsApiFetchParamCreator(configuration).restV1CardNumberTogglePost(number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Recupera una lista paginada de transacciones para una tarjeta específica
         * @summary Obtiene las transacciones de una tarjeta
         * @param {string} number Número de tarjeta
         * @param {number} pg Número de página
         * @param {number} pgSize Tamaño de página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTransactionsPgPgSizeGet(number: string, pg: number, pgSize: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = PrepaidCardsApiFetchParamCreator(configuration).restV1CardNumberTransactionsPgPgSizeGet(number, pg, pgSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permite transferir saldo entre dos cuentas Remesita especificadas por los números de tarjeta Visa.
         * @summary Transfiere saldo entre cuentas Remesita
         * @param {Body} body Detalles de la transferencia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardTransferBetweenPost(body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = PrepaidCardsApiFetchParamCreator(configuration).restV1CardTransferBetweenPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Devuelve una lista de todas las tarjetas prepagadas en el sistema
         * @summary Obtiene la lista de tarjetas prepagadas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PrepaidCardsApiFetchParamCreator(configuration).restV1CardsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PrepaidCardsApi - factory interface
 * @export
 */
export const PrepaidCardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Cambia el estado de bloqueo de una tarjeta específica
         * @summary Bloquea o desbloquea una tarjeta
         * @param {string} number Número de tarjeta
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTogglePost(number: string, options?: any) {
            return PrepaidCardsApiFp(configuration).restV1CardNumberTogglePost(number, options)(fetch, basePath);
        },
        /**
         * Recupera una lista paginada de transacciones para una tarjeta específica
         * @summary Obtiene las transacciones de una tarjeta
         * @param {string} number Número de tarjeta
         * @param {number} pg Número de página
         * @param {number} pgSize Tamaño de página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardNumberTransactionsPgPgSizeGet(number: string, pg: number, pgSize: number, options?: any) {
            return PrepaidCardsApiFp(configuration).restV1CardNumberTransactionsPgPgSizeGet(number, pg, pgSize, options)(fetch, basePath);
        },
        /**
         * Permite transferir saldo entre dos cuentas Remesita especificadas por los números de tarjeta Visa.
         * @summary Transfiere saldo entre cuentas Remesita
         * @param {Body} body Detalles de la transferencia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardTransferBetweenPost(body: Body, options?: any) {
            return PrepaidCardsApiFp(configuration).restV1CardTransferBetweenPost(body, options)(fetch, basePath);
        },
        /**
         * Devuelve una lista de todas las tarjetas prepagadas en el sistema
         * @summary Obtiene la lista de tarjetas prepagadas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1CardsGet(options?: any) {
            return PrepaidCardsApiFp(configuration).restV1CardsGet(options)(fetch, basePath);
        },
    };
};

/**
 * PrepaidCardsApi - object-oriented interface
 * @export
 * @class PrepaidCardsApi
 * @extends {BaseAPI}
 */
export class PrepaidCardsApi extends BaseAPI {
    /**
     * Cambia el estado de bloqueo de una tarjeta específica
     * @summary Bloquea o desbloquea una tarjeta
     * @param {string} number Número de tarjeta
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrepaidCardsApi
     */
    public restV1CardNumberTogglePost(number: string, options?: any) {
        return PrepaidCardsApiFp(this.configuration).restV1CardNumberTogglePost(number, options)(this.fetch, this.basePath);
    }

    /**
     * Recupera una lista paginada de transacciones para una tarjeta específica
     * @summary Obtiene las transacciones de una tarjeta
     * @param {string} number Número de tarjeta
     * @param {number} pg Número de página
     * @param {number} pgSize Tamaño de página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrepaidCardsApi
     */
    public restV1CardNumberTransactionsPgPgSizeGet(number: string, pg: number, pgSize: number, options?: any) {
        return PrepaidCardsApiFp(this.configuration).restV1CardNumberTransactionsPgPgSizeGet(number, pg, pgSize, options)(this.fetch, this.basePath);
    }

    /**
     * Permite transferir saldo entre dos cuentas Remesita especificadas por los números de tarjeta Visa.
     * @summary Transfiere saldo entre cuentas Remesita
     * @param {Body} body Detalles de la transferencia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrepaidCardsApi
     */
    public restV1CardTransferBetweenPost(body: Body, options?: any) {
        return PrepaidCardsApiFp(this.configuration).restV1CardTransferBetweenPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Devuelve una lista de todas las tarjetas prepagadas en el sistema
     * @summary Obtiene la lista de tarjetas prepagadas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrepaidCardsApi
     */
    public restV1CardsGet(options?: any) {
        return PrepaidCardsApiFp(this.configuration).restV1CardsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Devuelve el balance y otros detalles relacionados
         * @summary Obtiene datos de balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BalanceGet(options: any = {}): FetchArgs {
            const localVarPath = `/rest/v1/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodePost(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling restV1UserLockupCodeCodePost.');
            }
            const localVarPath = `/rest/v1/user/lockup-code/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Devuelve el balance y otros detalles relacionados
         * @summary Obtiene datos de balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BalanceGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).restV1BalanceGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodePost(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).restV1UserLockupCodeCodePost(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Devuelve el balance y otros detalles relacionados
         * @summary Obtiene datos de balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1BalanceGet(options?: any) {
            return ProfileApiFp(configuration).restV1BalanceGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restV1UserLockupCodeCodePost(code: string, options?: any) {
            return ProfileApiFp(configuration).restV1UserLockupCodeCodePost(code, options)(fetch, basePath);
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Devuelve el balance y otros detalles relacionados
     * @summary Obtiene datos de balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public restV1BalanceGet(options?: any) {
        return ProfileApiFp(this.configuration).restV1BalanceGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public restV1UserLockupCodeCodePost(code: string, options?: any) {
        return ProfileApiFp(this.configuration).restV1UserLockupCodeCodePost(code, options)(this.fetch, this.basePath);
    }

}

